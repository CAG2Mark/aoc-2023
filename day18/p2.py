from typing import List

DIRS = {
    '0': (0, 1),
    '2': (0, -1),
    '3': (-1, 0),
    '1': (1, 0)
}
def solve(inp: List[str]):
    filled = set()

    minr = 100000
    minc = 100000
    maxr = -100000
    maxc = -100000

    curr = 0
    curc = 0

    rgrid = set()
    cgrid = set()
    rgrid.add(0)
    cgrid.add(0)
    
    # Build coordinate map
    for ln in inp:
        ins = ln.split()[2][2:-1]
        direction = ins[-1]
        dist = int(ins[:-1], 16)

        (dr, dc) = DIRS[direction]

        oldr = curr
        oldc = curc

        curr += dr * dist
        curc += dc * dist

        # We want to encode the entire rectangle generated by
        # [oldr, curr] x [oldc, curc]
        # using the coordinates
        # our compression system is start inclusive, end exclusive

        lr = min(oldr, curr)
        ur = max(oldr, curr)
        lc = min(oldc, curc)
        uc = max(oldc, curc)
        
        rgrid.add(lr)
        rgrid.add(ur + 1)
        cgrid.add(lc)
        cgrid.add(uc + 1)
    
    rgrid = list(rgrid)
    cgrid = list(cgrid)

    rgrid.sort()
    cgrid.sort()

    # add min and max to each rgrid cgrid
    # (will be used to make an empty perimeter in flood and fill later)
    rgrid.insert(0, rgrid[0] - 1)
    rgrid.append(rgrid[-1] + 1)
    cgrid.insert(0, cgrid[0] - 1)
    cgrid.append(cgrid[-1] + 1)

    invr = {}
    invc = {}

    for i, r in enumerate(rgrid):
        invr[r] = i
    for i, c in enumerate(cgrid):
        invc[c] = i
    
    curr = 0
    curc = 0

    # Do the problem as before
    for ln in inp:
        ins = ln.split()[2][2:-1]
        direction = ins[-1]
        dist = int(ins[:-1], 16)

        (dr, dc) = DIRS[direction]

        oldr = curr
        oldc = curc

        curr += dr * dist
        curc += dc * dist

        # We want to encode the entire rectangle generated by
        # [oldr, curr] x [oldc, curc]
        # using the coordinates
        # our compression system is start inclusive, end exclusive

        lr = min(oldr, curr)
        ur = max(oldr, curr) + 1
        lc = min(oldc, curc)
        uc = max(oldc, curc) + 1

        lr = invr[lr]
        ur = invr[ur]
        lc = invc[lc]
        uc = invc[uc]
        
        for r in range(lr, ur):
            for c in range(lc, uc):
                minr = min(minr, r)
                minc = min(minc, c)
                maxr = max(maxr, r + 1)
                maxc = max(maxc, c + 1)

                filled.add((r, c))

    return interior(filled, minr, minc, maxr, maxc, rgrid, cgrid)

def compute_area(filled, rgrid, cgrid):
    total = 0
    for (r, c) in filled:
        lenr = rgrid[r + 1] - rgrid[r]
        lenc = cgrid[c + 1] - cgrid[c]
        total += lenr * lenc
    return total

def interior(filled, minr, minc, maxr, maxc, rgrid, cgrid):
    perimeter = compute_area(filled, rgrid, cgrid)


    st = [(minr, minc)]
    while st:
        (r, c) = st.pop()
        for (dr, dc) in DIRS.values():
            newr = r + dr
            newc = c + dc

            if not (minr - 1 <= newr < maxr + 1 and minc - 1 <= newc < maxc + 1):
                continue

            if (newr, newc) in filled:
                continue

            filled.add((newr, newc))
            st.append((newr, newc))

    minr_real = rgrid[0]
    maxr_real = rgrid[-1]
    minc_real = cgrid[0]
    maxc_real = cgrid[-1]
    
    area = (maxc_real - minc_real) * (maxr_real - minr_real)
    
    return area - compute_area(filled, rgrid, cgrid) + perimeter
    

        